3. Update the page
Now that we can get data from an API, let’s update the page to display the data we fetched.

Understand the data received
Here’s a sample output from the API call. It’s quite a substantial data structure. So, let’s go over it and pick out parts that are useful for experimenting with SPAs.

[
  {
    "word": "code",                                                                                 
    "phonetic": "/kəʊd/",                                                                           
    "phonetics": [
      {
        "text": "/kəʊd/",
        "audio": "https://api.dictionaryapi.dev/media/pronunciations/en/code-uk.mp3",
        "sourceUrl": "https://commons.wikimedia.org/w/index.php?curid=89012322",
        "license": {
          "name": "BY-SA 4.0",
          "url": "https://creativecommons.org/licenses/by-sa/4.0"
        }
      },
      {
        "text": "/koʊd/",
        "audio": ""
      }
    ],
    "meanings": [
      {
        "partOfSpeech": "noun",                                                                       
        "definitions": [                                                                              
          {
            "definition": "A short symbol, often with little relation to the item it represents.",
            // ... omitted for brevity
          },
          {
            "definition": "A body of law, sanctioned by legislation, in which the rules of law to be specifically applied by the courts are set forth in systematic form; a compilation of laws by public authority; a digest.",
            // ...
          },
          // ...
        ]
      },
      // ...
    ],
    // ...
  }
]
Here’s the word itself, taking note that it part of an object in a top-level array.
And it’s phonetic form.
Notice that the meanings are grouped by part of speech.
And that each part of speech has multiple definitions.
To confirm our ability to update a page dynamically, we will only display the word, phonetic and the list of definitions for the first part of speech. An sample of HTML code we would like to inject into the page is shown below.

<h2>code  /kəʊd/</h2>
<h3>Meanings</h2
<h4>noun</h4>
<ol>
  <li>A short symbol, often with little relation to the item it represents.</li>
  <li>A body of law, sanctioned by legislation, in which the rules of law to be specifically applied by the courts are set forth in systematic form; a compilation of laws by public authority; a digest.</li>

  <!-- ... omitted for brevity -->
</ol>
We will update the page dynamically using three different techniques.

By replacing a fragment of the DOM directly with new nodes.

By generating an HTML string to replace the content of an existing DOM node.

By using a template library.

Using DOM nodes
Copy app-2.html to app-3a.html, and app-2.js to app-3a.js.

Then change app-3a.html to load app-3a.js.

You should be able to make such changes by now.

Edit app-3a.js to include the following code.

public/js/app-3a.js
window.addEventListener("load", () => {
    const options = {
        method: 'GET',
    };

    const word = 'code';

    fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`, options)
        .then(response => response.json())
        .then(data => {
            const content = data[0];                                                                        
            const div = document.createElement('div')                                                       
            div.appendChild(createElementWithContent('h2', content.word + '&nbsp;' + content.phonetic));    
            div.appendChild(createElementWithContent('h3', "Meanings"));                                    
            div.appendChild(createElementWithContent('h4', content.meanings[0].partOfSpeech));              
            div.appendChild(createListWithContent('ol', content.meanings[0].definitions, 'definition'));    
            document.getElementById('app').replaceChildren(div);                                            
        });


    function createElementWithContent(type, content) {                                                      
        const el = document.createElement(type);
        el.innerHTML = content;
        return el;
    }

    function createListWithContent(type, list, property) {                                                  
        const el = document.createElement(type);
        list.forEach(item => el.appendChild(createElementWithContent('li', item[property])));
        return el;
    }
});
We’re only going to show the data for the first element in the JSON array.
Create a new node. It’s a div and is currently not attached to the DOM.
Append an h2 element with the word and phonetic by calling the utility function createElementWithContent.
And the heading Meanings.
Ditto for the part of speech.
We use another utility function to append a list of nodes as an unordered list ol with the content being the definition property of each element in the array of definitions.
Finally, we get the app node in the DOM and replace its children with the div tree of nodes that we built up earlier.
Here’s the function to create an element with some content. Notice that we simply update the innerHTML for the node.
And the function to create a tree of nodes from an array. We pick out the property we need and use it in a node that we attach to the unordered list node.
Re-run the app and the page should now contain a list of definitions of the word code.

Using strings
Let’s try updating the page using another approach. We will generate the HTML as a string to be inserted into the page.

NOTE
Copy app-3a.html to app-3b,html, app-3a.js to app-3b.js and update app-3b.html to load app-3b.js.

Edit app.js to include the following code.

public/js/app-3b.js
window.addEventListener("load", () => {
    const options = {
        method: 'GET',
    };

    const word = 'code';

    fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`, options)
        .then(response => response.json())
        .then(data => {
            const content = data[0];
            const meaning = content.meanings[0];                                                      

            const html =                                                                              
            `                                                         
                <h2>${content.word}&nbsp;&nbsp;${content.phonetic}</h2>                                     
                <h3>Meanings</h3>
                <h4>${meaning.partOfSpeech}</h4>
                <ol>
                    ${listOfDefinitions(meaning.definitions)}                                                         
                </ol>
            `;
            document.getElementById('app').innerHTML = html;                                          
        });
});

function listOfDefinitions(definitions) {                                                             
    return definitions.reduce((previous, current) => previous + `<li>${current.definition}</li>`, '');
}
For convenience in string interpolation later on, get the first meaning element from the JSON object.
We use string interpolation to build up the HTML. It’s a very basic emplate of sorts!
Since the html uses string interpolation, it will resolve the values of the interpolated variables. All we need to do is replace the innerHTML of the DOM node we want to update.
This function generates a string of HTML li elements from an array of definitions.
Re-run the app and the page should now contain a list of definitions of the word code.

Using a template library
Since the string generation approach showed the potential convenience of taking a template-based approach, let’s use template library and see if that helps even more. The template library we will use is Handlebars.

Let’s get cracking!

NOTE
Copy app-3b.html to app-3c,html, app-3b.js to app-3c.js and update app-3c.html to load app-3c.js.

Update app-3b.html to include Handlebars and create and inline template. Do read the comments inline to understand how we include the JS library and setup the template.

There are other ways to declare a template, such as in a string in a JS file, or as a compiled resource on the server that is loaded as a JS file. We’re going for a simple way of using it inline and uncompiled.
public/app-3c.html
<!DOCTYPE html>
<html>

<head>
    <title>A Simple SPA</title>

    <link
        href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAOjv4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEBEAAAAAEBAAABAQAAAQEREREBAAABEREREREAAAARAREBEAAAAAEREREAAAAAABAAEAAAAAAAEAAQAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAD//wAA//8AAP//AAD//wAA//8AAPyfAADr6wAA6AsAAOADAADyJwAA+A8AAP3fAAD93wAA++8AAP//AAD//wAA"
        rel="icon" type="image/x-icon" />                    
</head>

<body>
    <h1>All pages will have this heading</h1>

    <div id="app">
        And the app will dynamically change this content.
    </div>

<!-- We will load the Handlebars library directly off a CDN provider.
     We could save a local copy in our source code, but that is best managed with 
     a JS dependency manager such as yarn. That requires you to have node.js setup too.
     None of that is our focus, so just get it from the CDN.  -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.7.7/handlebars.min.js"></script>

<!-- We can embed the template in a script tag. By specifying the type as non-javascript, 
     the browser will not try to execute the contents of this element.
     Also, using a script tag, we know that the unbound template will not be rendered.
     This keeps all the content in the page, and not scattered between JS and HTML pages.  -->
    <script id="template" type="text/handlebars-template">
        <h2>{{word}} &nbsp; {{phonetic}}</h2>                                     
        <h3>Meanings</h3>
        <h4>{{partOfSpeech}}</h4>
        <ol>
            {{#each definitions}}
                <li>{{this.definition}}
            {{/each}}
        </ol>
    </script>

    <script type="text/javascript" src="/js/app-3c.js"></script> 
</body>

</html>
Update app-3c.js to use Handlebars.

public/js/app-3c.js
window.addEventListener("load", () => {
    const options = {
        method: 'GET',
    };

    const word = 'code';

    fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`, options)
        .then(response => response.json())
        .then(data => {
            data = {                                                                        
                word: data[0].word,
                phonetic: data[0].phonetic,
                partOfSpeech: data[0].meanings[0].partOfSpeech,
                definitions: data[0].meanings[0].definitions
            };
            const template = document.getElementById('template').innerText;                 
            const compiledFunction = Handlebars.compile(template);                          
            document.getElementById('app').innerHTML = compiledFunction(data);              
        });
});
Construct an object that matches that expected by template. This is, in essence, the model that is bound to the view template.
Get the contents of the template from the DOM.
Compile the template which returns a function that we then use to bind the model to the view.
Call the template function to bind the provided data to the placeholders in the template.
Running the app should give you the same result.
